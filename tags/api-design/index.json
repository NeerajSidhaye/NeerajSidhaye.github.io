[{"content":"I have put together my notes around some of the basic microservices design principles which we must always consider while designing a microservice.\nDesign principles for MicroServices 1. Develop and Deployed independently Each service should be developed and deployed independently. Deployment of one service should not impact other services and a each service should have it\u0026rsquo;s own code base.\nYou are doing wrong if\n You find a need to deploy services together You have one code base for multiple services You need to send notification to before you deploy a service  2. Data Ownership Service should have it\u0026rsquo;s own database or preferably set of tables that is manged by only a specific service. Should avoid scenario where multiple services are writing and reading from the same set of tables, any changes to table would require changes in all services.\nHaving each service has it\u0026rsquo;s own data ownership introduce loose coupling between service and database.\nkey point is, services should NOT have knowledge of each others underlying database.\nHaving own database for a services allows to choose right database technologies based on service functionality.\n3. Loosely coupled from all other services once you adhere to point 1 and 2, you have already initiated loose coupling but there are points to address on loose coupling:-\nminimal dependency on other services Communication with other services should be over exposed public interfaces( API, events etc ) and such interfaces or API should NOT expose internal details.\n4. Follow High Cohesion Methodology Closely related functionality must stay together in a single service. this minimizes intercommunication between services.\n5. Resilient service Single point of failure in system should NOT impact multiple services. if you have a service with independent data ownership, loose coupling, independent deployable artifact, it is a step towards resilient system!\nRemember - Total resilience in the face of all situations is NOT possible.Implement what is feasible in the short term and work to achieve greater resilience in stages.\n6. Shared Library Carefully watch out implications of shared library introduction to your services. You are doing something wrong when changes to shared library requires updates to all services simultaneously.\n7. Introduce Asynchronous Workers Very important design principle - introduce asynchronous workers to minimize impact on primary service API.\nExample -\u0026gt; A batch job can be introduced in a service as an asynchronous worker which is responsible to process high volume request, re-try mechanism for failed request etc.\nThis asynchronous worker provide following benefits:-\n Speed up the primary request path Spread load to asynchronous worker in case of high volume request Reduce error scenarios on primary API.  8. Service Versioning An API is never going to be completely stable. Change is inevitable!!\nIt\u0026rsquo;s always a best practice to version your service. Versioning can be added to header or in the service url. Following technique can be used to maintain service version:-\nThe URL has a major version number (v1), but the API has date based sub- versions which can be chosen using a custom HTTP request header. In this case, the major version provides structural stability of the API as a whole while the sub-versions accounts for smaller changes (field deprecations, endpoint changes, etc).\n","description":"Microservices at it's core is based on designing a bunch of small services based on specific business capabilities. Small service means, it should minimize complexity, should serve a focused purpose and should minimize inter-service communication. Importantly, each microservices should be built as a PRODUCT!\"","id":2,"section":"posts","tags":["API Design","MicroServices"],"title":"Microservices - Design Principle","uri":"https://neerajsidhaye.github.io/posts/api/designprinciple/"},{"content":"This post describes basics of\n SSE concepts SSE use cases How does SSE work Message Formats SSE code on Client side and Server side SseEmitter connection keep alive time Auto Re-connect mechanism  SSE Concepts  Server Sent Events are the events ( data ) sent from server to the client over HTTP connection.\nThis connection is one directional connection from server to client. Meaning that, once the client connects to server, then there after server will send any real-time notifications generated on the server side, to the client.\nClient can be mobile app or browser based app, or any client that support HTTP Connection.\nSSE use cases You would have seen SSE use cases around you in day to day life\n Continuous update about train time notifications on the display panel on the platform. Continuous Rolling of Stock updates. Real time counter increment of your social media \u0026lsquo;likes\u0026rsquo; icon and could be more\u0026hellip;  How does SSE work Client initiates a connection to server over http, this can be done by client calling a rest end point on the server, in return, the response should have content-type header values as text/event-stream\nThis tells the client, that a connection is established and stream is opened for sending events from the server to the client.\nIn the browser you have a special object called, EventSource, that handles the connection and converts the responses into events.\nMessage-Formats SSE only supports text data. Meaning, server can only send text data to the client.\nBinary streaming, while possible, is inefficient with SSE. In that case, WebSocket would be good choice for binary data transfer.\nSSE code - Client side and Server side Client Side Code EventSource object is the core object supported by browser. To open a connection to the server, client will need to instantiate EventSource object.\n1  const eventSource = new EventSource(\u0026#39;http://localhost:8080/subscribe/\u0026#39;);   Browser sends this GET request with accept header text/event-stream.The response to this request, must contain header content-type with value text/event-stream and response must be encoded with UTF-8.\nTo process these events in the browser an application needs to register a istener for the message event.\nThe property data of the event object contains the message\n1 2 3 4  eventSource.onmessage = event =\u0026gt; { const msg = JSON.parse(event.data); // access your attributes from the msg. };   Client api supports certain events like open and error. Open event occurs as soon as 200 response is received by client for /subscribe GET call. Error event is received by client, when there is any network error or server terminates the connection.\nServer Side Code Http Response to the above GET request on /subscribe end point must contain the Content-Type header with the value text/event-stream.\nSpring Boot supports SSE by providing SseEmitter object. It was introduced in spring version 4.2 ( spring boot 1.3 ).\nCreate a spring boot application from start.spring.io and select web as dependency.\nYou can have a controller with rest end point GET with /subscribe allows client to establish connection.\nAnother rest end point POST with /event allows us to submit new events on the server. This POST with /events or similar end point, can be called from any other server side component to send real time notification.\nThis /event end point, will then send event to connected clients.\nEach client connection is represented with it\u0026rsquo;s own instance of SseEmitter.\nOne limitation with spring SSE is , it does not give you tools to manage these SseEmitter instances. So, for this example, I have used a list that stores SseEmitter objects and release objects on errors, completion or timeout scenarios.\nSseEmitter object is created as below\n1  SseEmitter emitter = new SseEmitter();   SseEmitter connection keep alive time By default, Spring Boot with the embedded Tomcat server keeps the SSE HTTP connection open for 30 seconds.We can override this 30 seconds via configurations.\nspring.mvc.async.request-timeout=50000\rthis entry will keep the HTTP connection open for 50 seconds. Alternatively, you can directly use SseEmitter constructor to pass this timeout value as below\nSseEmitter emitter = new SseEmitter(150_000L); //keep connection open for 150 seconds\rAuto Re-connect mechanism The nice thing about Server-Sent Events is that they have a built in re-connection feature. Meaning that, if the connection is dropped due to server error then client will automatically tries to re-connect after 3 seconds.\nThe browser tries to send reconnect requests forever until he gets a 200 HTTP response back.\nIt\u0026rsquo;s a browser feature to wait for 3 seconds and then automatically reconnect. This 3 seconds of time can be changed by the server by sending a new time value in the retry header attribute together with the message.\nA client can be told to stop reconnecting using the HTTP 204 No Content response code.\nDid you find this page helpful? Consider sharing it ðŸ™Œ ","description":"Server Sent Events - Concept, Use case, how SSE works, message formats, SSE code sample, SseEmitter connection keep alive time and Auto Reconnect mechanism","id":3,"section":"posts","tags":["Server Sent Events","SSE","EventSource"],"title":"Server Sent Events - Concepts","uri":"https://neerajsidhaye.github.io/posts/sse/sse/"}]